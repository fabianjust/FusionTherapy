%mocap_data
%
%Created by David Mauderli - 2019
%
%DESCRIPTION: This class simulates Motion Capture measurments generated by
%Motive and is individualized for the BridgeT study protocol.
%
%USAGE:
%   1.) Specify measurment time and sampling frequency by constructor and/or
%       setDuration()
%   2.) Specify armlengths and marker positions with setMarkersRefpos()
%   3.) Specify according to which rule joint angles should change with
%       setTheta()
%   4.) Simulate and save with simulate() and save()
%DEPENDENCIES: cell2csv.m

classdef mocap_data < handle
    properties %(Access = protected)
        %Recording Properties
        T;                              %Duration of the whole recording
        Fs;                             %Sampling Frequency
        FNAME;                          %Filename
        PATH;                           %Absolute Path
        %Anatomy Properties (Joint Centers/Origins of technical coords)
        p_sho_glob;                     %Center of uarm ccs in global coords
        p_elb_uarm;                     %Center of elbow ccs in uarm coords
        p_hnd_larm;                     %Center of hand joint ccs in larm coords
        %Marker positions in technical frames (4xN_markers)
        torso;                          
        uarm_ut;
        elb_ut;
        larm_lt;
        hand_lt;
        startstop
        %Joint angles for every frame
        A_theta;                        %Array containing joint angles
                                        %Abd,sfle,srot,efle,epro
        coordDescr;                     %Names of coordinates
        markerDescr;                    %Markerinfo
        A_markerData;                   %Coordinates of markers for every frame

    end
    methods

        %% Constructor and Measurment properties: Set Sampling Rate and Duration
        %int Fs, double duration, char[] PATH, char[] FNAME
        function obj = mocap_data(Fs,duration,PATH,FNAME)
            if nargin == 0
                obj.T = NaN;
                obj.Fs = NaN;
                obj.FNAME = "noName";
                obj.PATH = uigetdir();
            elseif nargin == 4
                obj.T = duration;
                obj.Fs = Fs;
                obj.FNAME = FNAME;
                obj.PATH = PATH;
            elseif nargin == 2
                obj.Fs = Fs;
                obj.T = duration;
            end
        end

        
        %Specify sampling rate and measurment duration
        %int Fs, double duration
        function obj = setDuration(obj,Fs,duration)
            obj.Fs = Fs;
            obj.T = duration;
        end

        %Specify filename and absolute path
        function obj = setFname(obj,PATH,FNAME)
            obj.FNAME = FNAME;
            obj.PATH = PATH;
        end

        %% Simulation Properties
        %FUNCTION: setMarkersRefpos
        %INPUT: double sho_offset, double uarm_length, double larm_length
        %Defines the skeleton by the following variables:
        %   -Shoulder offset (distance torso_1 to shoulder jointcenter)
        %   -Elbow offset (distance shoulder joint to elbow joint)
        %   -Larm length (distance elbow joint to wrist)
        %Note: 
        %Units: [m]
        %Global Coordinate System: x-Axis orthogonal to sagital plane, y-axis
        %orthogonal to coronal plane
        %
        %Further introduces marker positions in technical coordinates and
        %in reference position.
        
        function obj = setMarkersRefpos(obj,sho_offset,uarm_length,larm_length)
            %Define locations of join centers in technical coordinates
            %Use std if no input
            if nargin == 1
                obj.p_sho_glob = [0.3;0;0];
                obj.p_elb_uarm = [0;0.4;0];
                obj.p_hnd_larm = [0;0.3;0];
            %Use input args if present
            elseif nargin == 4
                obj.p_sho_glob = [sho_offset;0;0];
                obj.p_elb_uarm = [0;uarm_length;0];
                obj.p_hnd_larm = [0;larm_length;0];
            end

            %Set torso markers in torso technical CCS (technical torso CCS = global
            %CCS)
            torso_1 = [0;0;-0.05];
            torso_2 = [0.05;0;0];
            torso_3 = [-0.05;0;0];
            torso_4 = [0.1;0;0.05];
            torso_5 = [-0.1;0;0.05];
            torso_6 = [0;0;-0.15];
            torso_7 = [0;-0.1;0.05];
            torso_8 = [0;-0.1;-0.15];
            obj.torso = [torso_1, torso_2, torso_3, torso_4, torso_5, torso_6, torso_7, torso_8];
            %Set uarm markers in uarm CCS
            uarm_1_ut = [0;    0.15;   0];
            uarm_2_ut = [0;    0.15;   0.05];
            uarm_3_ut = [0.05; 0.15;   0];
            uarm_4_ut = [0.05; 0.15;   0.05];
            obj.uarm_ut = [uarm_1_ut, uarm_2_ut, uarm_3_ut, uarm_4_ut];
            %Set elb markers in uarm CCS
            elb_1_ut = obj.p_elb_uarm + [0;0;-0.05];
            elb_2_ut = obj.p_elb_uarm + [0;0;0.05];
            obj.elb_ut = [elb_1_ut, elb_2_ut];
            %Set larm markers in larm CCS
            larm_1_lt = [0; 0.1 ; 0.05];
            larm_2_lt = [0;0.15;-0.05];
            larm_3_lt = [0.05;0.05;0];
            larm_4_lt = [-0.05;0.1;0.07];
            larm_5_lt = obj.p_hnd_larm+[0;0;0.05];
            larm_6_lt = obj.p_hnd_larm+[0;0;0];
            obj.larm_lt = [larm_1_lt, larm_2_lt, larm_3_lt, larm_4_lt, larm_5_lt, larm_6_lt];
            %Set hand markers in larm CCS
            hand_1 = larm_6_lt+[0;0.05;0];
            hand_2 = larm_5_lt+[0;0.05;0];
            obj.hand_lt = [hand_1, hand_2];
        end
    
        %FUNCTION: setTheta
        %INPUT:
        %cell<function handle>(1,5): Those functions will be evaluated for
        %every time step. 
        %double(1,5) sigma: Gaussian noise with mean=0 and variance=sigma
        %can be specified for every axis (1-5).
        %
        %Defines joint angles for axes 1-5 for every frame. Accepts
        %function handles and applies functions for every timestep. Adds
        %gaussian noise with variance sigma. 
        %Note:
        %ax1 = abduction
        %ax2 = shoulder flexion
        %ax3 = shoulder rotation
        %ax4 = elbow flexion
        %ax5 = elbow extension
        
        %!!!!!!ANGLES IN DEGREES!!!!!!
        function obj = setTheta(obj, fcn_hdls,sigma)
            assert(~isempty(obj.T),'mocap_data:writeTheta',...
            'Recording length and sampling frequency not defined!')
        
            %Time vector for time discretization
            t_vec = linspace(0,obj.T,obj.Fs*obj.T);
            obj.A_theta = NaN(5,length(t_vec));
            
            [b,a] = butter(4,0.06);            
            %If 5 input arguments --> periodic function
            for i=1:5
                noise = normrnd(0,sigma(i),1,length(t_vec));
                noise = filtfilt(b,a,noise);
                obj.A_theta(i,:) = fcn_hdls{i}(t_vec)+noise;
            end
        end
            
        function a = getFs(obj)
            a = obj.Fs;
        end
        function a = getA_theta(obj)
            a = obj.A_theta;
        end
        %% Simulation functions
        %FUNCTION: simulate
        %Computes marker positions (global coordinates) at every frame for
        %the specified joint angles AND reference position.
        function obj = simulate(obj,t_start,t_stop)
            n_fra = size(obj.A_theta,2);
            obj.A_markerData = NaN(n_fra,24*3+2);
            for curr_fra=1:n_fra
                %Define Rotation Matrices
                R_ua = rotz(obj.A_theta(1,curr_fra))*rotx(obj.A_theta(2,curr_fra))*roty(obj.A_theta(3,curr_fra));
                R_la = rotz(obj.A_theta(4,curr_fra))*roty(obj.A_theta(5,curr_fra));
                %Transform from lower arm ccs to upper arm ccs
                larm_ut = R_la*obj.larm_lt+obj.p_elb_uarm;
                hand_ut = R_la*obj.hand_lt+obj.p_elb_uarm;
                %Transform from upper arm ccs to torso ccs
                uarm_gl = R_ua*obj.uarm_ut+obj.p_sho_glob;
                elb_gl = R_ua*obj.elb_ut+obj.p_sho_glob;
                larm_gl = R_ua*larm_ut+obj.p_sho_glob;
                hand_gl = R_ua*hand_ut+obj.p_sho_glob;
                if curr_fra == obj.Fs*t_start
                    start = hand_gl(:,1);
                end
                if curr_fra == obj.Fs*t_stop
                    stop = hand_gl(:,1);
                end
        
                %Write to Marker data array
                all_markers = [obj.torso, uarm_gl, elb_gl, larm_gl, hand_gl, obj.startstop];
                obj.A_markerData(curr_fra,3:3:22*3)=all_markers(1,:);
                obj.A_markerData(curr_fra,4:3:22*3+1)=all_markers(2,:);
                obj.A_markerData(curr_fra,5:3:22*3+2)=all_markers(3,:);
                obj.A_markerData(curr_fra,1) = curr_fra;
                obj.A_markerData(curr_fra,2) = curr_fra/obj.Fs;
            end
            obj.A_markerData(:,69:74) = ones(n_fra,6).*[start',stop']+0.005*rand(1,6);
        end
        
        %FUNCTION: save
        %char[] PATH: Absolute Path
        %char[] FNAME: Filename
        %Saves the simulation data to a .csv file. Data is formated similar
        %to Motive data --> BridgeT code can process those csv files
        function save(obj, PATH, FNAME)
        
        if nargin == 3
            FPATH = [PATH, '\',FNAME];
        elseif nargin == 1
            FPATH = [obj.PATH, '\',obj.FNAME];
        end

        %Write third line (Marker Descriptor)
        outputCell(1,3:74) = repmat({"Marker"},1,72);

        %Write fourth line (Marker names)
        %Torso marker names
        current_start = 3;
        for i=0:7
            current_range = current_start+3*i+(0:2);
            current_cells = repmat({strcat("torso_",num2str(i+1))},1,3);
            outputCell(2,current_range) = current_cells;
        end
        %Uarm marker names
        current_start = current_start+3*size(obj.torso,2);
        for i=0:3
            current_range = current_start+3*i+(0:2);
            current_cells = repmat({strcat("uarm_",num2str(i+1))},1,3);
            outputCell(2,current_range) = current_cells;
        end
        %Elbow marker names
        current_start = current_start + 3*size(obj.uarm_ut,2);
        for i=0:1
            current_range = current_start+3*i+(0:2);
            current_cells = repmat({strcat("elb_",num2str(i+1))},1,3);
            outputCell(2,current_range) = current_cells;
        end
        %Larm marker names
        current_start = current_start + 3*size(obj.elb_ut,2);
        for i=0:5
            current_range = current_start+3*i+(0:2);
            current_cells = repmat({strcat("larm_",num2str(i+1))},1,3);
            outputCell(2,current_range) = current_cells;
        end
        %Hand marker names
        current_start = current_start + 3*size(obj.larm_lt,2);
        for i=0:1
            current_range = current_start+3*i+(0:2);
            current_cells = repmat({strcat("hand_",num2str(i+1))},1,3);
            outputCell(2,current_range) = current_cells;
        end
        
        current_start = current_start + 3*size(obj.hand_lt,2);
        outputCell(2,current_start+(0:2)) = repmat({"start_1"},1,3);
        current_start = current_start + 3;
        outputCell(2,current_start+(0:2)) = repmat({"stop_1"},1,3);

        %Write fifth line (empty)
        outputCell(3,3:74) = repmat({""},1,72);

        %Write sixth line (Position)
        outputCell(4,3:74) = repmat({"Position"},1,72);

        %Write seventh line (Coord Descr)
        outputCell(5,3:74) = repmat({"X","Y","Z"},1,24);
        outputCell(5,1) = {"Frame"};
        outputCell(5,2) = {"Time"};

        %Write Data
        outputCell(6:(obj.Fs*obj.T+5),1:74) = num2cell(obj.A_markerData);

        %Save to csv file
        cell2csv(FPATH,outputCell,',')
        end
    end
end